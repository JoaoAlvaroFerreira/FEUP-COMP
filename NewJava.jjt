options {
  LOOKAHEAD=1;
}
PARSER_BEGIN(NewJava)

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.io.*;

public class NewJava
{
  public static void main(String args[]) throws ParseException {
    String filePath = "exemplo1.jmm";
    String fileContents = fileToString(filePath);
    NewJava myJava = new NewJava(new ByteArrayInputStream(fileContents.getBytes()));
    SimpleNode root = myJava.Program();
    root.dump("");

    System.out.println("F*CK JAS");
  }

  private static String fileToString(String filePath)
  {
    String content = "";

    try
    {
        content = new String ( Files.readAllBytes( Paths.get(filePath) ) );
    }
    catch (IOException e)
    {
        System.out.println(e.toString());
    }

    return content;
  }
}

PARSER_END(NewJava)
SKIP :
{
  " " | "\r" | "\t" | "\n" | "\n "
}
TOKEN:
{
  < CLASS: "class" >
  | < EXTENDS: "extends" >
  | < OPERATORS: "&&" | "<" | "+" | "-" | "*" | "/" >
  | < BRACKETOPEN: "[" >
  | < BRACKETCLOSE: "]" >
  | < FULLSTOP: "." >
  | < COMMA: "," >
  | < SEMICOLON: ";" >
  | < NOT: "!" >
  | < ROUNDBRACKETOPEN: "(" >
  | < ROUNDBRACKETCLOSED: ")" >
  | < CURLYBRACKETOPENED: "{" >
  | < CURLYBRACKETCLOSED: "}" >
  | < ASSERT: "=">
  | < TRUE: "true" >
  | < FALSE: "false" >
  | < THIS: "this" >
  | < NEW: "new" >
  | < LENGTH: "length" >
  | < INT: "int" >
  | < PUBLIC: "public" >
  | < STATIC: "static" >
  | < VOID: "void" >
  | < MAIN: "main" >
  | < RETURN: "return" >
  | < STRING: "String" >
  | < BOOLEAN: "boolean" >
  | < IF: "if">
  | < ELSE: "else">
  | < WHILE: "while">
  | < INTEGERLITERAL: (["0" - "9"])+ >
  | < IDENTIFIER: ["A"-"Z","a"-"z"](["0"-"9","A"-"Z","a"-"z","_"])* >
}
SimpleNode Program(): {}
{
  ClassDeclaration() <EOF> {return jjtThis;}
}

void ClassDeclaration()#void:  {}
{
  try{
    <CLASS> <IDENTIFIER> (<EXTENDS> <IDENTIFIER>)? <CURLYBRACKETOPENED>(VarDeclaration())*(<PUBLIC> (MainDeclaration()|MethodDeclaration()))*<CURLYBRACKETCLOSED>
  }catch(ParseException e) {
    System.out.println(e.toString());
  }
}

//while (1 < ) ;

void VarDeclaration()#void: {Token t;}
{
  try{
    Type() t=<IDENTIFIER> <SEMICOLON>{
      jjtThis.symbol=t.image;
    }#VAR
  }catch(ParseException e) {
    System.out.println(e.toString());
  }
}

void Type()#void: {}
{
  try{
    <INT> [<BRACKETOPEN> <BRACKETCLOSE>]
    | <BOOLEAN>
    | <IDENTIFIER>
  }catch(ParseException e) {
    System.out.println(e.toString());
  }
}

void MainDeclaration()#MAIN: {}
{
    <STATIC> <VOID> <MAIN> <ROUNDBRACKETOPEN> <STRING> <BRACKETOPEN> <BRACKETCLOSE> <IDENTIFIER> <ROUNDBRACKETCLOSED> <CURLYBRACKETOPENED>
    (LOOKAHEAD(2) VarDeclaration()|Statement())*
    <CURLYBRACKETCLOSED>
}

void MethodDeclaration()#FUNCTION: {Token name; }
{
  try{
    Type() name=<IDENTIFIER> <ROUNDBRACKETOPEN> (Type() <IDENTIFIER> (<COMMA> Type() <IDENTIFIER>)*)? <ROUNDBRACKETCLOSED> <CURLYBRACKETOPENED>
    (LOOKAHEAD(2) VarDeclaration()|Statement())*
    <RETURN> Expression() <SEMICOLON> <CURLYBRACKETCLOSED>
    {
      jjtThis.symbol = name.image;
    }#RETURN(1)
  }catch(ParseException e) {
    System.out.println(e.toString());
  }
}

void Statement()#void:{Token t=new Token();}
{
    <CURLYBRACKETOPENED> (Statement())* <CURLYBRACKETCLOSED>
  | <IF> IfStatement() 
  | <WHILE> WhileStatement()
  | <IDENTIFIER> [<BRACKETOPEN>  Expression() <BRACKETCLOSE>] <ASSERT> Expression() <SEMICOLON>
}

void IfStatement()#IF:{}
{
  <ROUNDBRACKETOPEN> Expression() <ROUNDBRACKETCLOSED> Statement() [<ELSE> Statement()]
}

void WhileStatement()#WHILE: {}
{

 <ROUNDBRACKETOPEN> Expression() <ROUNDBRACKETCLOSED> Statement()

}

void Expression()#void: {}
{
  try{
    VarTerm() [Expr2()]
  }catch(ParseException e) {
    System.out.println(e.toString());
  }
}

void Expr2()#void: {Token t;}
{
  try{
    <FULLSTOP> (<LENGTH> [Expr2()] |
    <IDENTIFIER> <ROUNDBRACKETOPEN> [Expression()(<COMMA> Expression())*]  <ROUNDBRACKETCLOSED> [Expr2()])
    | t=<OPERATORS> Expression()
      {
        jjtThis.symbol = t.image;
      }#OP(2)
    | <BRACKETOPEN> Expression() <BRACKETCLOSE> [Expr2()]
  }catch(ParseException e) {
    System.out.println(e.toString());
  }
}

void VarTerm()#void: {Token t;Token open = new Token();Token close = new Token();}
{
  try{
    t=<INTEGERLITERAL>
      {
        jjtThis.symbol = t.image;
      }#VAL
    | t=<IDENTIFIER>
      {
        jjtThis.symbol = t.image;
      }#TEXT
    | <TRUE> #TRUE
    | <FALSE> #FALSE
    | <THIS> #THIS
    | <NEW> (t=<INT> open=<BRACKETOPEN> Expression() close=<BRACKETCLOSE> {
      jjtThis.symbol = t.image;
    }#NEW(1)
    | t=<IDENTIFIER> open=<ROUNDBRACKETOPEN> close=<ROUNDBRACKETCLOSED>
    {
      jjtThis.symbol = t.image;
    }#NEW
    )
    | <NOT> Expression() #NOT(1)
    | <ROUNDBRACKETOPEN> Expression() <ROUNDBRACKETCLOSED> #BRACKETS(1)
  }catch(ParseException e) {
    System.out.println(e.toString());
  }
}
