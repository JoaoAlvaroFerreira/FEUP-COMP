options {
  LOOKAHEAD=1;
}

PARSER_BEGIN(ExpressionParsing)

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.io.*;

public class ExpressionParsing
{
  public static void main(String args[]) throws ParseException {
    String filePath = "exemplo2.jmm";
    String fileContents = fileToString(filePath);
    ExpressionParsing myJava = new ExpressionParsing(new ByteArrayInputStream(fileContents.getBytes()));
    SimpleNode root = myJava.Program();
    root.dump("");

    System.out.println("F*CK JAS");
  }

  private static String fileToString(String filePath)
  {
    String content = "";

    try
    {
        content = new String ( Files.readAllBytes( Paths.get(filePath) ) );
    }
    catch (IOException e)
    {
        e.printStackTrace();
    }

    return content;
  }
}

PARSER_END(ExpressionParsing)

SKIP :
{
  " " | "\r" | "\t" | "\n"
}
TOKEN:
{
  < OPERATORS: "&&" | "<" | "+" | "-" | "*" | "/" >
  | < BRACKETOPEN: "[" >
  | < BRACKETCLOSE: "]" >
  | < FULLSTOP: "." >
  | < COMMA: "," >
  | < NOT: "!" >
  | < ROUNDBRACKETOPEN: "(" >
  | < ROUNDBRACKETCLOSED: ")" >
  | < TRUE: "true" >
  | < FALSE: "false" >
  | < THIS: "this" >
  | < LENGTH: "length" >
  | < NEW: "new" >
  | < INT: "int" >
  | < INTEGERLITERAL: (["0" - "9"])+ >
  | < IDENTIFIER: ["A"-"Z","a"-"z"](["0"-"9","A"-"Z","a"-"z","_"])* >
}
SimpleNode Program(): {}
{
  Expression() <EOF> {return jjtThis;}
}

void Expression()#void: {}
{
 VarTerm() [Expr2()]
}

void Expr2()#void: {}
{
  try{
  <FULLSTOP> ("length" [Expr2()] |
  <IDENTIFIER> <ROUNDBRACKETOPEN> [Expression()(<COMMA> Expression())*]  <ROUNDBRACKETCLOSED> [Expr2()])
  | <OPERATORS>  Expression()
}catch(ParseException e) {
  e.printStackTrace();
}
}

void VarTerm()#void: {}
{
  Expr1() <LF> {return jjtThis;}
}

void Expr1() #void : {}
{
  VarTerm() [Expr3()]
}

void VarTerm(): {}
{
  <INTEGERLITERAL>
  | <IDENTIFIER>
  | <TRUE>
  | <FALSE>
  | <THIS>
  | <NEW> (<INT> <BRACKETOPEN> Expr1() <BRACKETCLOSE> | <IDENTIFIER> <ROUNDBRACKETOPEN> <ROUNDBRACKETCLOSED>)
  | <NOT> Expr1()
  | <ROUNDBRACKETOPEN> Expr1() <ROUNDBRACKETCLOSED>
}

void Expr3(): {}
{
  <FULLSTOP> (<LENGTH> [Expr3()] | <IDENTIFIER> <ROUNDBRACKETOPEN> [Expr1() (<COMMA> Expr1())*] <ROUNDBRACKETCLOSED>] [Expr3()])
  | <OPERATORS> Expr1() 
  | <BRACKETOPEN> Expr1() <BRACKETCLOSE> [Expr3()]
}
