import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.stream.Stream;

/* Generated By:JJTree: Do not edit this line. SimpleNode.java Version 6.0 */
/* JavaCCOptions:MULTI=false,NODE_USES_PARSER=false,VISITOR=false,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
public class SimpleNode implements Node {

  protected Node parent;
  protected Node[] children;
  protected int id;
  protected Object value;
  protected NewJava parser;
  protected String symbol;
  protected int line;
  protected int column;

  public SimpleNode(int i) {
    id = i;
  }

  public SimpleNode(NewJava p, int i) {
    this(i);
    parser = p;
  }

  public void jjtOpen() {
  }

  public void jjtClose() {
  }

  public void jjtSetParent(Node n) {
    parent = n;
  }

  public Node jjtGetParent() {
    return parent;
  }

  public void jjtAddChild(Node n, int i) {
    if (children == null) {
      children = new Node[i + 1];
    } else if (i >= children.length) {
      Node c[] = new Node[i + 1];
      System.arraycopy(children, 0, c, 0, children.length);
      children = c;
    }
    children[i] = n;
  }

  public Node jjtGetChild(int i) {
    return children[i];
  }

  public int jjtGetNumChildren() {
    return (children == null) ? 0 : children.length;
  }

  public void jjtSetValue(Object value) {
    this.value = value;
  }

  public Object jjtGetValue() {
    return value;
  }

  /*
   * You can override these two methods in subclasses of SimpleNode to customize
   * the way the node appears when the tree is dumped. If your output uses more
   * than one line you should override toString(String), otherwise overriding
   * toString() is probably all you need to do.
   */

  public String toString() {
    return NewJavaTreeConstants.jjtNodeName[id];
  }

  public String toString(String prefix) {
    return prefix + toString();
  }

  /*
   * Override this method if you want to customize how the node dumps out its
   * children.
   */

  public void dump(String prefix) {
    System.out.print(toString(prefix));
    if (this.symbol != null)
      System.out.print(" " + this.symbol);
    System.out.println();
    if (children != null) {
      for (int i = 0; i < children.length; ++i) {
        SimpleNode n = (SimpleNode) children[i];
        if (n != null) {
          n.dump(prefix + " ");
        }
      }
    }
  }

  public int getId() {
    return id;
  }

  public String getSymbol() {
    return symbol;
  }

  public Object getValue() {
    return value;
  }

  public int getLineNumber() {
    return line;
  }

  public void setLineNumber(int lineNumber) {
    this.line = lineNumber;
  }

  public int getColumnNumber() {
    return column;
  }

  public void dumpLineError(String filePath, int lineNum, int col) {
    try (Stream<String> lines = Files.lines(Paths.get(filePath))) {
      System.out.println(lines.skip(lineNum - 1).findFirst().get());
      while (col > 1) {
        System.out.print(" ");
        col--;
      }
      System.out.print("^");
      System.out.println();
    } catch (IOException e) {
      e.printStackTrace();
    }
  }

  @Override
  public Object visit(SymbolTable data, int functionNum) {
    if (id == NewJava.JJTVAR) {
      String name = (String) this.getSymbol();

      String type = data.checkIfExists(name, functionNum); // checkar locais

      if (type.equals("error")) {
        type = data.searchParam(name, functionNum); // checkar params
      }

      if (type.equals("error")) {
        type = data.checkIfExistGlobals(name); // checkar globais
      }

      if (!type.contains("/")) { // variable has unique name
        if ((!type.equals("int") && !type.equals("boolean") && !type.equals("int[]")) || type.equals("error")) {
          if (this.jjtGetNumChildren() > 0) {
            if (!Main.tables.containsKey(this.jjtGetChild(0).getSymbol())) { // checkar se Ã© outra classe

              int lineNum = this.jjtGetChild(0).getLineNumber();
              System.out.println("\n" + data.filePath + ":" + lineNum + ": error: cannot find symbol");

              dumpLineError(data.filePath, lineNum, ((SimpleNode) this.jjtGetChild(0)).getColumnNumber());

              System.out.println("    symbol:   class " + ((SimpleNode) this.jjtGetChild(0)).getSymbol());
              System.out.println("    location: class " + data.className + "\n");
              return "error";
            } else {
              return this.jjtGetChild(0).getSymbol();
            }
          }
        }
      } else {
        String[] responseArr = type.split("/");

        int lineNum = Integer.parseInt(responseArr[0]);

        // node with repeated variable name
        if (lineNum == this.line) {
          String args;
          args = "(";

          int index;
          while ((index = responseArr[2].indexOf("->")) != -1) {
            if (args.length() > 1) {
              args += ", ";
            }

            int finalIndex = responseArr[2].indexOf(",");
            if (finalIndex == -1) {
              finalIndex = responseArr[2].indexOf("]");
            }

            args += responseArr[2].substring(index + 3, finalIndex);
            responseArr[2] = responseArr[2].substring(finalIndex + 1);
          }
          args += ")";

          System.out.println("\n" + data.filePath + ":" + lineNum + ": error: variable " + this.symbol
              + " is already defined in method " + responseArr[1] + args);

          dumpLineError(data.filePath, lineNum, this.getColumnNumber());

          return "error";
        }
      }
      return type.toString();
    }

    if (id == NewJava.JJTTRUE || id == NewJava.JJTFALSE) {
      return "boolean";
    }

    if (id == NewJava.JJTVAL) {
      return "int";
    }

    if (id == NewJava.JJTNEW) {
      return symbol;
    }

    // type of arguments
    if (id == NewJava.JJTTEXT) {
      String type = data.checkIfExists(this.getSymbol(), functionNum);

      if (type.equals("error")) {
        type = data.searchParam(symbol, functionNum);
      }

      if (type.equals("error")) {
        type = data.checkIfExistGlobals(symbol);
      }

      return type;
    }

    if ((id == NewJava.JJTOP2) || (id == NewJava.JJTOP3) || (id == NewJava.JJTOP4) || (id == NewJava.JJTOP5)) {
      boolean ok = checkOpType(this, data, functionNum);
      if (!ok) {
        System.out.println("\n" + data.filePath + ":" + line + ": error: bad operand types for binary operator '" + symbol + "'");

        dumpLineError(data.filePath, line, column);
        return "error";
      }
      return "int";
    }

    if (id == NewJava.JJTASSIGN) {
      
      //Lado esquerdo
      String identifierType = (String) this.jjtGetChild(0).visit(data, functionNum);

      // Lado direito assign
      String expressionType = (String) this.jjtGetChild(1).visit(data, functionNum);

      if(identifierType.equals("int[]") && !expressionType.equals("int[]")){
        identifierType = "int";
      }

      if(!identifierType.equals("int[]") && expressionType.equals("int[]")){
        expressionType = "int";
      }
      
      // previous semantic error: already defined variable
      if (((String) identifierType).contains("/")) {
        return "error";
      }

      // Lado esquerdo assign
      if (identifierType.equals("error")) {
        int lineNum = this.jjtGetChild(0).getLineNumber();
        System.out.println("\n" + data.filePath + ":" + lineNum + ": error: cannot find symbol");

        dumpLineError(data.filePath, lineNum, ((SimpleNode) this.jjtGetChild(0)).getColumnNumber());

        System.out.println("    symbol:   variable " + ((SimpleNode) this.jjtGetChild(0)).getSymbol());
        System.out.println("    location: file " + data.filePath + "\n");

        return "error";
      }

      // previous semantic error: already defined variable
      if (((String) expressionType).contains("/")) {
        return "error";
      }

      if (!identifierType.equals(expressionType)) {
        int lineNum = this.jjtGetChild(0).getLineNumber();
        System.out.println("\n" + data.filePath + ":" + lineNum + ": error: incompatible types: " + expressionType
            + " cannot be converted to " + identifierType);

        dumpLineError(data.filePath, lineNum, ((SimpleNode) this.jjtGetChild(1)).getColumnNumber());
        return "error";
      }

      data.initializedVariables.add(((SimpleNode) this.jjtGetChild(0)).getSymbol());
    }

    // Function type must match return type
    if (this.id == NewJava.JJTRETURN) {
      String type = (String) ((SimpleNode) this.jjtGetChild(0)).visit(data, functionNum);
      String dataType = data.getReturn(functionNum);

      if (!type.equals(dataType)) {
        int lineNum = this.jjtGetChild(0).getLineNumber();
        System.out.println("\n" + data.filePath + ":" + lineNum + ": error: incompatible types: " + type
            + " cannot be converted to " + dataType);
        dumpLineError(data.filePath, lineNum, ((SimpleNode) this.jjtGetChild(0)).getColumnNumber());
        return "error";
      }
    }

    // check function calls (right param number or function exists)
    if (id == NewJava.JJTFULLSTOP) {

      if(this.jjtGetChild(1).getId() == NewJava.JJTPAREMETER){
        return "int";
      }
      String type = (String) this.jjtGetChild(0).visit(data, functionNum);

      if (Main.tables.containsKey(type)) {
        SimpleNode rightSide = (SimpleNode) this.jjtGetChild(1);
        SymbolTable tableAux = Main.tables.get(type);

        for (SymbolTableEntry var : tableAux.entries) {
          if (var.name.equals(rightSide.getSymbol())) {
            if (var.params.size() != rightSide.jjtGetNumChildren()) {
              int lineNum = rightSide.getLineNumber();

              System.out.println("\n" + data.filePath + ":" + lineNum + ":  error: method " + var.name + " in class "
                  + data.className + " cannot be applied to given types;");
              dumpLineError(data.filePath, lineNum, rightSide.getColumnNumber());
              System.out.print("    required: ");
              for (int i = 0; i < var.params.size(); i++) {
                System.out.print(var.params.get(i).type);
                if (i < var.params.size() - 1) {
                  System.out.print(",");
                }
              }
              System.out.print("\n    found: ");
              for (int i = 0; i < rightSide.jjtGetNumChildren(); i++) {
                String typeArg = (String) ((SimpleNode) rightSide.jjtGetChild(i)).visit(data, functionNum);
                System.out.print(typeArg);
                if (i < rightSide.jjtGetNumChildren() - 1) {
                  System.out.print(",");
                }
              }
              System.out.println("\n    reason: actual and formal argument lists differ in length");
              return "error";
            } else {
              for (int i = 0; i < var.params.size(); i++) {
                String typeArg = (String) ((SimpleNode) rightSide.jjtGetChild(i)).visit(data, functionNum);
                if (!var.params.get(i).type.equals(typeArg)) {
                  int lineNum = this.jjtGetChild(0).getLineNumber();
                  System.out.println("\n" + data.filePath + ":" + lineNum + ": error: incompatible types: " + typeArg
                      + " cannot be converted to " + var.params.get(i).type);
                  dumpLineError(data.filePath, lineNum, ((SimpleNode) rightSide.jjtGetChild(i)).getColumnNumber());
                  return "error";
                }
              }
            }

            return var.returnDescriptor;
          }
        }

        int lineNum = this.jjtGetChild(0).getLineNumber();
        System.out.println("\n" + data.filePath + ":" + lineNum + ": error: cannot find symbol");

        dumpLineError(data.filePath, lineNum, rightSide.getColumnNumber());

        System.out.println("    symbol: method " + rightSide.getSymbol() + "()");
        System.out.println("    location: file " + data.filePath + "\n");
        return "error";
      }

      return this.jjtGetParent().jjtGetChild(0).visit(data, functionNum);
    }

    if (id == NewJava.JJTIF || id == NewJava.JJTWHILE) {
      String conditionType = (String) ((SimpleNode) this.jjtGetChild(0)).visit(data, functionNum);

      if (!conditionType.equals("boolean") && !conditionType.equals("int") && !conditionType.equals("error") && NewJava.JJTOP2 != this.jjtGetChild(0).getId() && NewJava.JJTOP3 != this.jjtGetChild(0).getId()) {
        int lineNum = this.jjtGetChild(0).getLineNumber();
        System.out.println("\n" + data.filePath + ":" + lineNum + ": error: incompatible types: " + conditionType + " cannot be converted to boolean");

        dumpLineError(data.filePath, lineNum, ((SimpleNode) this.jjtGetChild(0)).getColumnNumber());
        return "error";
      }

      if (this.jjtGetChild(0).getId() == NewJava.JJTTEXT && !data.initializedVariables.contains(this.jjtGetChild(0).getSymbol())) {
        int lineNum = this.jjtGetChild(0).getLineNumber();
        System.out.println("\n" + data.filePath + ":" + lineNum + ": error: variable " + this.jjtGetChild(0).getSymbol() + " might not have been initialized");

        dumpLineError(data.filePath, lineNum, this.jjtGetChild(0).getColumnNumber());
        return "error";
      }
    }

    return "";
  }

  private boolean checkOpType(SimpleNode startOP, SymbolTable data, int functionNum) {
    if (startOP.jjtGetNumChildren() != 2) {
      return false;
    }

    // check if variable is initialized
    if (startOP.jjtGetChild(0).getId() == NewJava.JJTTEXT
        && !data.initializedVariables.contains(startOP.jjtGetChild(0).getSymbol())) {
      int lineNum = startOP.jjtGetChild(0).getLineNumber();
      System.out.println("\n" + data.filePath + ":" + lineNum + ": error: variable "
          + startOP.jjtGetChild(0).getSymbol() + " might not have been initialized");

      dumpLineError(data.filePath, lineNum, startOP.jjtGetChild(0).getColumnNumber());
      return true;
    }

    // ramo esquerdo
    // se nao for op, verifica se e inteiro
    if (startOP.jjtGetChild(0).getId() != NewJava.JJTOP2 && startOP.jjtGetChild(0).getId() != NewJava.JJTOP3
        && startOP.jjtGetChild(0).getId() != NewJava.JJTOP4 && startOP.jjtGetChild(0).getId() != NewJava.JJTOP5) {
      String type = (String) startOP.jjtGetChild(0).visit(data, functionNum);

      if (!type.equals("int")) {
        return false;
      }
      // se for op, verifica se e vailda
    } else if (!checkOpType((SimpleNode) startOP.jjtGetChild(0), data, functionNum)) {
      return false;
    }

    if (startOP.jjtGetChild(1).getId() == NewJava.JJTTEXT
        && !data.initializedVariables.contains(startOP.jjtGetChild(1).getSymbol())) {
      int lineNum = startOP.jjtGetChild(1).getLineNumber();
      System.out.println("\n" + data.filePath + ":" + lineNum + ": error: variable "
          + startOP.jjtGetChild(1).getSymbol() + " might not have been initialized");

      dumpLineError(data.filePath, lineNum, startOP.jjtGetChild(1).getColumnNumber());

      return true;
    }

    // ramo direito
    if (startOP.jjtGetChild(1).getId() != NewJava.JJTOP2 && startOP.jjtGetChild(1).getId() != NewJava.JJTOP3
        && startOP.jjtGetChild(1).getId() != NewJava.JJTOP4 && startOP.jjtGetChild(1).getId() != NewJava.JJTOP5) {
      String type = (String) startOP.jjtGetChild(1).visit(data, functionNum);

      if (!type.equals("int")) {
        return false;
      }
    } else if (!checkOpType((SimpleNode) startOP.jjtGetChild(1), data, functionNum)) {
      return false;
    }

    return true;
  }

}

/*
 * JavaCC - OriginalChecksum=9eef391808ffa9c1f856b164b9ceaad4 (do not edit this
 * line)
 */
