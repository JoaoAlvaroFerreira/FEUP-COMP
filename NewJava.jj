/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. NewJava.jj */
/*@egen*/options {
  LOOKAHEAD=1;
}
PARSER_BEGIN(NewJava)

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.io.*;

public class NewJava/*@bgen(jjtree)*/implements NewJavaTreeConstants/*@egen*/
{/*@bgen(jjtree)*/
  protected static JJTNewJavaState jjtree = new JJTNewJavaState();

/*@egen*/
  public static void main(String args[]) throws ParseException {
    String filePath = "exemplo1.jmm";
    String fileContents = fileToString(filePath);
    NewJava myJava = new NewJava(new ByteArrayInputStream(fileContents.getBytes()));
    SimpleNode root = myJava.Program();
    root.dump("");

    System.out.println("F*CK JAS");
  }

  private static String fileToString(String filePath)
  {
    String content = "";

    try
    {
        content = new String ( Files.readAllBytes( Paths.get(filePath) ) );
    }
    catch (IOException e)
    {
        e.printStackTrace();
    }

    return content;
  }
}

PARSER_END(NewJava)
SKIP :
{
  " " | "\r" | "\t" | "\n" | "\n "
}
TOKEN:
{
  < CLASS: "class" >
  | < EXTENDS: "extends" >
  | < OPERATORS: "&&" | "<" | "+" | "-" | "*" | "/" >
  | < BRACKETOPEN: "[" >
  | < BRACKETCLOSE: "]" >
  | < FULLSTOP: "." >
  | < COMMA: "," >
  | < SEMICOLON: ";" >
  | < NOT: "!" >
  | < ROUNDBRACKETOPEN: "(" >
  | < ROUNDBRACKETCLOSED: ")" >
  | < CURLYBRACKETOPENED: "{" >
  | < CURLYBRACKETCLOSED: "}" >
  | < TRUE: "true" >
  | < FALSE: "false" >
  | < THIS: "this" >
  | < NEW: "new" >
  | < LENGTH: "length" >
  | < INT: "int" >
  | < PUBLIC: "public" >
  | < STATIC: "static" >
  | < VOID: "void" >
  | < MAIN: "main" >
  | < RETURN: "return" >
  | < STRING: "String" >
  | < BOOLEAN: "boolean" >
  | < INTEGERLITERAL: (["0" - "9"])+ >
  | < IDENTIFIER: ["A"-"Z","a"-"z"](["0"-"9","A"-"Z","a"-"z","_"])* >
}
SimpleNode Program(): {/*@bgen(jjtree) Program */
  SimpleNode jjtn000 = new SimpleNode(JJTPROGRAM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Program */
  try {
/*@egen*/
  ClassDeclaration() <EOF>/*@bgen(jjtree)*/
                           {
                             jjtree.closeNodeScope(jjtn000, true);
                             jjtc000 = false;
                           }
/*@egen*/ {return jjtn000;}/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void ClassDeclaration()     :  {}
{
  <CLASS> <IDENTIFIER> (<EXTENDS> <IDENTIFIER>)? <CURLYBRACKETOPENED>(VarDeclaration())*(<PUBLIC> (MainDeclaration()|MethodDeclaration()))*<CURLYBRACKETCLOSED>
}

void VarDeclaration()     : {}
{
  Type() <IDENTIFIER> <SEMICOLON>
}

void Type()     : {}
{
  <INT> [<BRACKETOPEN> <BRACKETCLOSE>]
  | <BOOLEAN>
  | <IDENTIFIER>
}

void MainDeclaration()     : {}
{
  try{
  <STATIC> <VOID> <MAIN> <ROUNDBRACKETOPEN> <STRING> <BRACKETOPEN> <BRACKETCLOSE> <IDENTIFIER> <ROUNDBRACKETCLOSED> <CURLYBRACKETOPENED>(VarDeclaration())*/*(Statement())**/<CURLYBRACKETCLOSED>
}catch(ParseException e){
    System.out.println(e.toString());
    Token t;
    do {
      t = getNextToken();
    } while (t.kind != CURLYBRACKETCLOSED);
}
}

void MethodDeclaration()     : {}
{
  Type() <IDENTIFIER> <ROUNDBRACKETOPEN> (Type() <IDENTIFIER> (<COMMA> Type() <IDENTIFIER>)*)? <ROUNDBRACKETCLOSED> <CURLYBRACKETOPENED> (VarDeclaration())* /*(Statement())**/ <RETURN> Expression() <SEMICOLON> <CURLYBRACKETCLOSED>
}

void Expression()     : {}
{
 VarTerm() [Expr2()]
}

void Expr2()     : {}
{
  try{
  <FULLSTOP> ("length" [Expr2()] |
  <IDENTIFIER> <ROUNDBRACKETOPEN> [Expression()(<COMMA> Expression())*]  <ROUNDBRACKETCLOSED> [Expr2()])
  | <OPERATORS>  Expression() [Expr2()]
  | <BRACKETOPEN> Expression() <BRACKETCLOSE> [Expr2()]
}catch(ParseException e) {
  e.printStackTrace();
}
}

void VarTerm()     : {}
{
  <INTEGERLITERAL>
  | <IDENTIFIER>
  | <TRUE>
  | <FALSE>
  | <THIS>
  | <NEW> (<INT> <BRACKETOPEN> Expression() <BRACKETCLOSE> | <IDENTIFIER> <ROUNDBRACKETOPEN> <ROUNDBRACKETCLOSED>)
  | <NOT> Expression()
  | <ROUNDBRACKETOPEN> Expression() <ROUNDBRACKETCLOSED>
  | <BRACKETOPEN> Expression() <BRACKETCLOSE>
}